{
  "hash": "ac9011610e1f618f71e53ef11d6b6192",
  "result": {
    "markdown": "---\ntitle: Writing a training loop from scratch\nAuthor: \"[fchollet](https://twitter.com/fchollet)\"\ndate-created: 2019/03/01\ndate-last-modified: 2020/04/15\ndescription: Complete guide to writing low-level training & evaluation loops.\naliases:\n  - ../../tutorials/advanced/customization/custom-training/index.html\n---\n\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tensorflow)\nlibrary(keras)\nlibrary(tfdatasets)\n```\n:::\n\n\n## Introduction\n\nKeras provides default training and evaluation loops, `fit()` and\n`evaluate()`. Their usage is covered in the guide [Training & evaluation\nwith the built-in methods](/guides/training_with_built_in_methods/).\n\nIf you want to customize the learning algorithm of your model while\nstill leveraging the convenience of `fit()` (for instance, to train a\nGAN using `fit()`), you can subclass the `Model` class and implement\nyour own `train_step()` method, which is called repeatedly during\n`fit()`. This is covered in the guide [Customizing what happens in\n`fit()`](/guides/customizing_what_happens_in_fit/).\n\nNow, if you want very low-level control over training & evaluation, you\nshould write your own training & evaluation loops from scratch. This is\nwhat this guide is about.\n\n## Using the `GradientTape`: a first end-to-end example\n\nCalling a model inside a `GradientTape` scope enables you to retrieve\nthe gradients of the trainable weights of the layer with respect to a\nloss value. Using an optimizer instance, you can use these gradients to\nupdate these variables (which you can retrieve using\n`model$trainable_weights`).\n\nLet's consider a simple MNIST model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninputs <- layer_input(shape = shape(784), name = \"digits\")\noutputs <- inputs %>% \n  layer_dense(64, activation = \"relu\") %>% \n  layer_dense(64, activation = \"relu\") %>% \n  layer_dense(10, name = \"predictions\")\nmodel <- keras_model(inputs = inputs, outputs = outputs)\n```\n:::\n\n\nLet's train it using mini-batch gradient with a custom training loop.\nFirst, we're going to need an optimizer, a loss function, and a dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instantiate an optimizer.\noptimizer <- optimizer_sgd(learning_rate = 1e-3)\n\n# Instantiate a loss function.\nloss_fn <- loss_sparse_categorical_crossentropy(from_logits = TRUE)\n\n# Prepare the training dataset.\nbatch_size <- 64\nc(c(x_train, y_train), c(x_test, y_test)) %<-% dataset_mnist()\nx_train <- x_train %>% array_reshape(dim = c(60000, 784))/255\nx_test <- x_test %>% array_reshape(dim = c(10000, 784))/255\n\n# Reserve 10,000 samples for validation.\nx_val <- x_train[-(1:50000),]\ny_val <- y_train[-(1:50000)]\nx_train <- x_train[(1:50000),]\ny_train <- y_train[(1:50000)]\n\n# Prepare the training dataset.\ntrain_dataset <- list(x_train, y_train) %>% \n  tensor_slices_dataset() %>% \n  dataset_shuffle(buffer_size = 1024) %>% \n  dataset_batch(batch_size)\n\n# Prepare the validation dataset.\nval_dataset <- list(x_val, y_val) %>% \n  tensor_slices_dataset() %>% \n  dataset_batch(batch_size)\n```\n:::\n\n\nHere's our training loop:\n\n-   We open a `for` loop that iterates over epochs\n-   For each epoch, we open a `for` loop that iterates over the dataset,\n    in batches\n-   For each batch, we open a `GradientTape()` scope\n-   Inside this scope, we call the model (forward pass) and compute the\n    loss\n-   Outside the scope, we retrieve the gradients of the weights of the\n    model with regard to the loss\n-   Finally, we use the optimizer to update the weights of the model\n    based on the gradients\n\n::: callout-note\nIn the example `train_dataset` is a TensorFlow Dataset, thus it can't be\niterated in normal R `for` loops. That's why we wrap the second loop\ninto a `autograph` call. `autograph` will compile the expression into\nefficient TensorFlow code to quickly evaluate the loop.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepochs <- 2\nfor(epoch in seq_len(epochs)) {\n  cat(\"Start of epoch \", epoch, \"\\n\")\n  # Iterate over the batches of the dataset.\n  tfautograph::autograph(for (batch in train_dataset) {\n    # Open a GradientTape to record the operations run\n    # during the forward pass, which enables auto-differentiation.\n    with(tf$GradientTape() %as% tape, {\n      # Run the forward pass of the layer.\n      # The operations that the layer applies\n      # to its inputs are going to be recorded\n      # on the GradientTape.\n      logits <- model(batch[[1]], training = TRUE)  # Logits for this minibatch\n      \n      # Compute the loss value for this minibatch.\n      loss_value <- loss_fn(batch[[2]], logits)\n    })\n    \n    # Use the gradient tape to automatically retrieve\n    # the gradients of the trainable variables with respect to the loss.\n    grads <- tape$gradient(loss_value, model$trainable_weights)\n    \n    # Run one step of gradient descent by updating\n    # the value of the variables to minimize the loss.\n    optimizer$apply_gradients(zip_lists(grads, model$trainable_weights))\n    \n  })\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStart of epoch  1 \nStart of epoch  2 \n```\n:::\n:::\n\n\n## Low-level handling of metrics\n\nLet's add metrics monitoring to this basic loop.\n\nYou can readily reuse the built-in metrics (or custom ones you wrote) in\nsuch training loops written from scratch. Here's the flow:\n\n-   Instantiate the metric at the start of the loop\n-   Call `metric$update_state()` after each batch\n-   Call `metric$result()` when you need to display the current value of\n    the metric\n-   Call `metric$reset_states()` when you need to clear the state of the\n    metric (typically at the end of an epoch)\n\nLet's use this knowledge to compute `sparse_categorical_accuracy` on\nvalidation data at the end of each epoch:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get model\ninputs <- layer_input(shape = shape(784), name = \"digits\")\noutputs <- inputs %>% \n  layer_dense(64, activation = \"relu\") %>% \n  layer_dense(64, activation = \"relu\") %>% \n  layer_dense(10, name = \"predictions\")\nmodel <- keras_model(inputs = inputs, outputs = outputs)\n\n# Instantiate an optimizer.\noptimizer <- optimizer_sgd(learning_rate = 1e-3)\n\n# Instantiate a loss function.\nloss_fn <- loss_sparse_categorical_crossentropy(from_logits = TRUE)\n\n# Prepare the metrics.\ntrain_acc_metric <- metric_sparse_categorical_accuracy()\nval_acc_metric <- metric_sparse_categorical_accuracy()\n```\n:::\n\n\nHere's our training & evaluation loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nepochs <- 2\nfor(epoch in seq_len(epochs)) {\n  cat(\"Start of epoch \", epoch, \"\\n\")\n  tfautograph::autograph(for (batch in train_dataset) {\n    with(tf$GradientTape() %as% tape, {\n      logits <- model(batch[[1]], training = TRUE)\n      loss_value <- loss_fn(batch[[2]], logits)\n    })\n    grads <- tape$gradient(loss_value, model$trainable_weights)\n    optimizer$apply_gradients(zip_lists(grads, model$trainable_weights))\n\n    # Update training metric.\n    train_acc_metric$update_state(batch[[2]], logits)\n  })\n  \n  train_acc <- as.numeric(train_acc_metric$result())\n  cat(\"Training acc over epoch: \", train_acc, \"\\n\")\n  train_acc_metric$reset_states()\n\n  # Run a validation loop at the end of each epoch.\n  tfautograph::autograph(for(batch in val_dataset) {\n    val_logits <- model(batch[[1]], training = FALSE)\n    # Update val metrics\n    val_acc_metric$update_state(batch[[2]], val_logits)\n  })\n  \n  val_acc <- as.numeric(val_acc_metric$result())\n  cat(\"Validation acc over epoch: \", val_acc, \"\\n\")\n  val_acc_metric$reset_states()\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStart of epoch  1 \nTraining acc over epoch:  0.25572 \nValidation acc over epoch:  0.4228 \nStart of epoch  2 \nTraining acc over epoch:  0.5342 \nValidation acc over epoch:  0.6522 \n```\n:::\n:::\n\n\nIt's common to extract out the expressin inside the second loop into a\nnew function called `train_step`. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_step <- function(batch) {\n  with(tf$GradientTape() %as% tape, {\n      logits <- model(batch[[1]], training = TRUE)\n      loss_value <- loss_fn(batch[[2]], logits)\n  })\n  grads <- tape$gradient(loss_value, model$trainable_weights)\n  optimizer$apply_gradients(zip_lists(grads, model$trainable_weights))\n  \n  # Update training metric.\n  train_acc_metric$update_state(batch[[2]], logits)\n}\n```\n:::\n\n\n## Low-level handling of losses tracked by the model\n\nLayers & models recursively track any losses created during the forward\npass by layers that call `self$add_loss(value)`. The resulting list of\nscalar loss values are available via the property `model$losses` at the\nend of the forward pass.\n\nIf you want to be using these loss components, you should sum them and\nadd them to the main loss in your training step.\n\nConsider this layer, that creates an activity regularization loss:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayer_activity_regularization <- new_layer_class(\n  \"activity_regularization\",\n  call = function(inputs) {\n    self$add_loss(1e-2 * tf$reduce_sum(inputs))\n    inputs\n  }\n)\n```\n:::\n\n\nLet's build a really simple model that uses it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninputs <- layer_input(shape = shape(784), name = \"digits\")\noutputs <- inputs %>% \n  layer_dense(64, activation = \"relu\") %>% \n  # Insert activity regularization as a layer\n  layer_activity_regularization() %>% \n  layer_dense(64, activation = \"relu\") %>% \n  layer_dense(10, name = \"predictions\")\nmodel <- keras_model(inputs = inputs, outputs = outputs)\n```\n:::\n\n\nHere's what our training step should look like now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrain_step <- function(batch) {\n  with(tf$GradientTape() %as% tape, {    \n    logits <- model(batch[[1]], training = TRUE)\n    loss_value <- loss_fn(batch[[2]], logits)\n    # Add any extra losses created during the forward pass.\n    loss_value <- loss_value + do.call(sum, model$losses)\n  })\n  grads <- tape$gradient(loss_value, model$trainable_weights)\n  optimizer$apply_gradients(zip_lists(grads, model$trainable_weights))\n  train_acc_metric$update_state(batch[[2]], logits)\n  loss_value\n}\n```\n:::\n\n\n## Summary\n\nNow you know everything there is to know about using built-in training\nloops and writing your own from scratch.\n\nTo conclude, here's a simple end-to-end example that ties together\neverything you've learned in this guide: a DCGAN trained on MNIST\ndigits.\n\n## End-to-end example: a GAN training loop from scratch\n\nYou may be familiar with Generative Adversarial Networks (GANs). GANs\ncan generate new images that look almost real, by learning the latent\ndistribution of a training dataset of images (the \"latent space\" of the\nimages).\n\nA GAN is made of two parts: a \"generator\" model that maps points in the\nlatent space to points in image space, a \"discriminator\" model, a\nclassifier that can tell the difference between real images (from the\ntraining dataset) and fake images (the output of the generator network).\n\nA GAN training loop looks like this:\n\n1)  Train the discriminator.\n\n-   Sample a batch of random points in the latent space.\n-   Turn the points into fake images via the \"generator\" model.\n-   Get a batch of real images and combine them with the generated\n    images.\n-   Train the \"discriminator\" model to classify generated vs. real\n    images.\n\n2)  Train the generator.\n\n-   Sample random points in the latent space.\n-   Turn the points into fake images via the \"generator\" network.\n-   Get a batch of real images and combine them with the generated\n    images.\n-   Train the \"generator\" model to \"fool\" the discriminator and classify\n    the fake images as real.\n\nFor a much more detailed overview of how GANs works, see [Deep Learning\nwith Python](https://www.manning.com/books/deep-learning-with-python).\n\nLet's implement this training loop. First, create the discriminator\nmeant to classify fake vs real digits:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiscriminator <- keras_model_sequential(\n  name = \"discriminator\", \n  input_shape = shape(28, 28, 1)\n) %>% \n  layer_conv_2d(64, c(3, 3), strides = c(2, 2), padding = \"same\") %>% \n  layer_activation_leaky_relu(alpha = 0.2) %>% \n  layer_conv_2d(128, c(3, 3), strides = c(2, 2), padding = \"same\") %>% \n  layer_activation_leaky_relu(alpha = 0.2) %>% \n  layer_global_max_pooling_2d() %>% \n  layer_dense(1)\nsummary(discriminator)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel: \"discriminator\"\n____________________________________________________________________________\n Layer (type)                     Output Shape                  Param #     \n============================================================================\n conv2d_1 (Conv2D)                (None, 14, 14, 64)            640         \n leaky_re_lu_1 (LeakyReLU)        (None, 14, 14, 64)            0           \n conv2d (Conv2D)                  (None, 7, 7, 128)             73856       \n leaky_re_lu (LeakyReLU)          (None, 7, 7, 128)             0           \n global_max_pooling2d (GlobalMaxP  (None, 128)                  0           \n ooling2D)                                                                  \n dense_6 (Dense)                  (None, 1)                     129         \n============================================================================\nTotal params: 74,625\nTrainable params: 74,625\nNon-trainable params: 0\n____________________________________________________________________________\n```\n:::\n:::\n\n\nThen let's create a generator network, that turns latent vectors into\noutputs of shape `(28, 28, 1)` (representing MNIST digits):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatent_dim <- 128\ngenerator <- keras_model_sequential(\n  input_shape = shape(latent_dim), \n  name = \"generator\"\n) %>% \n  # We want to generate 128 coefficients to reshape into a 7x7x128 map\n  layer_dense(7 * 7 * 128) %>% \n  layer_activation_leaky_relu(alpha = 0.2) %>% \n  layer_reshape(c(7, 7, 128)) %>% \n  layer_conv_2d_transpose(128, c(4, 4), strides = c(2, 2), padding = \"same\") %>% \n  layer_activation_leaky_relu(alpha = 0.2) %>% \n  layer_conv_2d_transpose(128, c(4, 4), strides = c(2, 2), padding = \"same\") %>% \n  layer_activation_leaky_relu(alpha = 0.2) %>% \n  layer_conv_2d(1, c(7, 7), padding = \"same\", activation = \"sigmoid\")\n```\n:::\n\n\nHere's the key bit: the training loop. As you can see it is quite\nstraightforward. The training step function only takes 17 lines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Instantiate one optimizer for the discriminator and another for the generator.\nd_optimizer <- optimizer_adam(learning_rate = 0.0003)\ng_optimizer <- optimizer_adam(learning_rate = 0.0004)\n\n# Instantiate a loss function.\nloss_fn <- loss_binary_crossentropy(from_logits = TRUE)\n\ntrain_step <- function(real_images) {\n  # Sample random points in the latent space\n  random_latent_vectors <- tf$random$normal(shape = shape(batch_size, latent_dim))\n  # Decode them to fake images\n  generated_images <- generator(random_latent_vectors)\n  # Combine them with real images\n  combined_images <- tf$concat(list(generated_images, real_images), axis = 0L)\n  \n  # Assemble labels discriminating real from fake images\\\n  labels <- tf$concat(list(\n    tf$ones(shape(batch_size, 1)), \n    tf$zeros(shape(real_images$shape[[1]], 1))), \n    axis = 0L\n  )\n  # Add random noise to the labels - important trick!\n  labels <- labels + 0.05 * tf$random$uniform(labels$shape)\n  \n  # Train the discriminator\n  with(tf$GradientTape() %as% tape, {    \n    predictions <- discriminator(combined_images)\n    d_loss <- loss_fn(labels, predictions)  \n  })\n  \n  grads <- tape$gradient(d_loss, discriminator$trainable_weights)\n  d_optimizer$apply_gradients(zip_lists(grads, discriminator$trainable_weights))\n  \n  # Sample random points in the latent space\n  random_latent_vectors <- tf$random$normal(shape = shape(batch_size, latent_dim))\n  # Assemble labels that say \"all real images\"\n  misleading_labels <- tf$zeros(shape(batch_size, 1))\n  \n  # Train the generator (note that we should *not* update the weights\n  # of the discriminator)!\n  with(tf$GradientTape() %as% tape, {    \n    predictions <- discriminator(generator(random_latent_vectors))\n    g_loss <- loss_fn(misleading_labels, predictions)\n  })\n  \n  grads <- tape$gradient(g_loss, generator$trainable_weights)\n  g_optimizer$apply_gradients(zip_lists(grads, generator$trainable_weights))\n  list(d_loss, g_loss, generated_images)\n}\n```\n:::\n\n\nLet's train our GAN, by repeatedly calling `train_step` on batches of\nimages. Since our discriminator and generator are convnets, you're going\nto want to run this code on a GPU.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Prepare the dataset. We use both the training & test MNIST digits.\nbatch_size <- 64\nc(c(x_train, y_train), c(x_test, y_test)) %<-% dataset_mnist()\nx_train[] <- x_train/255\nx_test[] <- x_test/255\n\ndataset <- tensor_slices_dataset(x_train) %>% \n  dataset_concatenate(tensor_slices_dataset(x_test)) %>% \n  dataset_map(function(x) {\n    tf$cast(tf$expand_dims(x, -1L), tf$float32)\n  }) %>% \n  dataset_shuffle(1024) %>% \n  dataset_batch(batch_size)\n\nepochs <- 1  # In practice you need at least 20 epochs to generate nice digits.\nsave_dir <- \"./\"\nfor (epoch in seq_len(epochs)) {\n  cat(\"\\nStart epoch \", epoch, \"\\n\")\n  tfautograph::autograph(for (real_images in dataset) {\n    c(d_loss, g_loss, generated_images) %<-% train_step(real_images)\n  })\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nStart epoch  1 \n```\n:::\n\n```{.r .cell-code}\ngenerated_images[1,,,] %>% \n  image_array_save(path = \"generated_img.png\")\n```\n:::\n\n\n![](generated_img.png)\n\nThat's it! You'll get nice-looking fake MNIST digits after just \\~30s of\ntraining on the Colab GPU.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}