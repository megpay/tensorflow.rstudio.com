{
  "hash": "3910da906502ff87e26231a585de7998",
  "result": {
    "markdown": "---\ntitle: \"Image classification from scratch\"\nauthors:\n  - \"[fchollet](https://twitter.com/fchollet)\"\n  - \"[terrytangyuan](https://github.com/terrytangyuan) - R adaptation\"\n  - \"[t-kalinowski](https://github.com/t-kalinowski) - R adaptation\"\ndate-created: 2022/12/19\ndate-last-modified: !expr Sys.Date()\ndescription: \"Training an image classifier from scratch on the Kaggle Cats vs Dogs dataset.\"\ncategories: [vision]\naliases:\n  - ../guide/keras/examples/image_classification_from_scratch/index.html\n---\n\n\n## Introduction\n\nThis example shows how to do image classification from scratch, starting\nfrom JPEG image files on disk, without leveraging pre-trained weights or\na pre-made Keras Application model. We demonstrate the workflow on the\nKaggle Cats vs Dogs binary classification dataset.\n\nWe use the `image_dataset_from_directory` utility to generate the\ndatasets, and we use Keras image preprocessing layers for image\nstandardization and data augmentation.\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tensorflow)\nlibrary(keras)\nlibrary(tfdatasets)\nset.seed(1234)\n```\n:::\n\n\n## Load the data: the Cats vs Dogs dataset\n\n### Raw data download\n\nFirst, let's download the 786M ZIP archive of the raw data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"https://download.microsoft.com/download/3/E/1/3E1C3F21-ECDB-4869-8368-6DEBA77B919F/kagglecatsanddogs_5340.zip\"\noptions(timeout = 60 * 5) # 5 minutes\ndownload.file(url, destfile = \"kagglecatsanddogs_5340.zip\") # (786.7 MB)\n## To see a list of everything in the zip file:\n# zip::zip_list(\"kagglecatsanddogs_5340.zip\") |> tibble::as_tibble()\nzip::unzip(\"kagglecatsanddogs_5340.zip\")\n```\n:::\n\n\nNow we have a `PetImages` folder which contain two subfolders, `Cat` and\n`Dog`. Each subfolder contains image files for each category.\n\n\n::: {.cell paged.print='false'}\n\n```{.r .cell-code}\nfs::dir_info(\"PetImages\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 18\n  path         type   size permiss…¹ modification_time   user  group devic…²\n  <fs::path>   <fct> <fs:> <fs::per> <dttm>              <chr> <chr>   <dbl>\n1 …tImages/Cat dire…  272K rwx------ 2023-02-11 18:23:59 toma… toma…   66306\n2 …tImages/Dog dire…  272K rwx------ 2023-02-11 18:23:59 toma… toma…   66306\n# … with 10 more variables: hard_links <dbl>, special_device_id <dbl>,\n#   inode <dbl>, block_size <dbl>, blocks <dbl>, flags <int>,\n#   generation <dbl>, access_time <dttm>, change_time <dttm>,\n#   birth_time <dttm>, and abbreviated variable names ¹​permissions,\n#   ²​device_id\n```\n:::\n\n```{.r .cell-code}\nfs::dir_info(\"PetImages\", recurse = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 23,202 × 18\n   path       type    size permiss…¹ modification_time   user  group devic…²\n   <fs::path> <fct> <fs::> <fs::per> <dttm>              <chr> <chr>   <dbl>\n 1 …mages/Cat dire…   272K rwx------ 2023-02-11 18:23:59 toma… toma…   66306\n 2 …Cat/0.jpg file   11.9K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 3 …Cat/1.jpg file   16.5K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 4 …at/10.jpg file   34.5K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 5 …t/100.jpg file     30K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 6 …/1000.jpg file   25.7K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 7 …10000.jpg file  127.2K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 8 …10001.jpg file   26.4K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n 9 …10002.jpg file   25.6K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n10 …10003.jpg file   27.9K rw------- 2017-02-10 09:54:54 toma… toma…   66306\n# … with 23,192 more rows, 10 more variables: hard_links <dbl>,\n#   special_device_id <dbl>, inode <dbl>, block_size <dbl>, blocks <dbl>,\n#   flags <int>, generation <dbl>, access_time <dttm>, change_time <dttm>,\n#   birth_time <dttm>, and abbreviated variable names ¹​permissions,\n#   ²​device_id\n```\n:::\n:::\n\n\n### Filter out corrupted images\n\nWhen working with lots of real-world image data, corrupted images are a\ncommon occurrence. Let's filter out badly-encoded images that do not\nfeature the string \"JFIF\" in their header.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_deleted <- 0L\nfor(filepath in list.files(\"PetImages\", pattern = \"\\\\.jpg$\",\n                           recursive = TRUE, full.names = TRUE)) {\n  header <- readBin(filepath, what = \"raw\", n = 10)\n  if(!identical(header[7:10], charToRaw(\"JFIF\"))) {\n    n_deleted <- n_deleted + 1L\n    unlink(filepath)\n  }\n}\n\ncat(sprintf(\"Deleted %d images\\n\", n_deleted))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDeleted 0 images\n```\n:::\n:::\n\n\n## Generate a `Dataset`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimage_size <- c(180, 180)\nbatch_size <- 32\n\ntrain_ds <- image_dataset_from_directory(\n    \"PetImages\",\n    validation_split = 0.2,\n    subset = \"training\",\n    seed = 1337,\n    image_size = image_size,\n    batch_size = batch_size,\n)\nval_ds <- image_dataset_from_directory(\n    \"PetImages\",\n    validation_split = 0.2,\n    subset = \"validation\",\n    seed = 1337,\n    image_size = image_size,\n    batch_size = batch_size,\n)\n```\n:::\n\n\n## Visualize the data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbatch <- train_ds %>%\n  as_iterator() %>%\n  iter_next()\n\nstr(batch)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 2\n $ :<tf.Tensor: shape=(32, 180, 180, 3), dtype=float32, numpy=…>\n $ :<tf.Tensor: shape=(32), dtype=int32, numpy=…>\n```\n:::\n\n```{.r .cell-code}\nc(images, labels) %<-% batch\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndisplay_image_tensor <- function(x, ..., max = 255,\n                                 plot_margins = c(0, 0, 0, 0)) {\n  if(!is.null(plot_margins))\n    par(mar = plot_margins)\n\n  x %>%\n    as.array() %>%\n    drop() %>%\n    as.raster(max = max) %>%\n    plot(..., interpolate = FALSE)\n}\n\npar(mfrow = c(3, 3))\nfor (i in 1:9)\n  display_image_tensor(images[i,,,],\n                       plot_margins = rep(.5, 4))\n```\n\n::: {.cell-output-display}\n![](image_classification_from_scratch_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Using image data augmentation\n\nWhen you don't have a large image dataset, it's a good practice to\nartificially introduce sample diversity by applying random yet realistic\ntransformations to the training images, such as random horizontal\nflipping or small random rotations. This helps expose the model to\ndifferent aspects of the training data while slowing down overfitting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# If you are on an M1 mac, you may need to wrap this model definition in\n# with(tf$device(\"CPU\"), { ... })\n# https://stackoverflow.com/questions/69088577/apple-m1-i-got-no-registered-rngreadandskip-opkernel-for-gpu-devices-comp\n\ndata_augmentation <-\n  keras_model_sequential(input_shape = c(image_size, 3)) %>%\n  layer_random_flip(\"horizontal\") %>%\n  layer_random_rotation(factor = 0.1)\n```\n:::\n\n\nLet's visualize what the augmented samples look like, by applying\n`data_augmentation` repeatedly to the first image in the dataset:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(3, 3))\nfor (i in 1:9) {\n    images[4, , , , drop = FALSE] %>%\n    data_augmentation() %>%\n    display_image_tensor()\n}\n```\n\n::: {.cell-output-display}\n![](image_classification_from_scratch_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Standardizing the data\n\nOur image are already in a standard size (180x180), as they are being\nyielded as contiguous `float32` batches by our dataset. However, their\nRGB channel values are in the `[0, 255]` range. This is not ideal for a\nneural network; in general you should seek to make your input values\nsmall. Here, we will standardize values to be in the `[0, 1]` by using a\n`Rescaling` layer at the start of our model.\n\n## Two options to preprocess the data\n\nThere are two ways you could be using the `data_augmentation`\npreprocessor: **Option 1: Make it part of the model**, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- layer_input(shape = input_shape) %>%\n  data_augmentation() %>%\n  layer_rescaling(1./255)\n...  # Rest of the model\n```\n:::\n\n\nWith this option, your data augmentation will happen *on device*,\nsynchronously with the rest of the model execution, meaning that it will\nbenefit from GPU acceleration.\n\nNote that data augmentation is inactive at test time, so the input\nsamples will only be augmented during `fit()`, not when calling\n`evaluate()` or `predict()`.\n\nIf you're training on GPU, this may be a good option.\n\n**Option 2: apply it to the dataset**, so as to obtain a dataset that\nyields batches of augmented images, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naugmented_train_ds <- train_ds %>%\n  dataset_map(function(x, y) {\n    x <- data_augmentation(x, training = TRUE)\n    list(x, y)\n  })\n```\n:::\n\n\nWith this option, your data augmentation will happen **on CPU**,\nasynchronously, and will be buffered before going into the model (this\nis because all TF Dataset operations, include any defined in\n`dataset_map()`, are pinned to the CPU).\n\nIf you're training on CPU, this is the better option, since it makes\ndata augmentation asynchronous and non-blocking.\n\nIn our case, we'll go with the second option. If you're not sure which\none to pick, this second option (asynchronous preprocessing) is always a\nsolid choice.\n\n## Configure the dataset for performance\n\nLet's apply data augmentation to our training dataset, and let's make\nsure to use buffered prefetching so we can yield data from disk without\nhaving I/O becoming blocking:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Apply `data_augmentation` to the training images.\ntrain_ds <- train_ds %>%\n  dataset_map(function(images, labels) {\n    list(data_augmentation(images, training = TRUE),\n         labels)\n  })\n\n# Prefetching samples in GPU memory helps maximize GPU utilization.\ntrain_ds %<>% dataset_prefetch()\nval_ds   %<>% dataset_prefetch()\n```\n:::\n\n\n## Build a model\n\nWe'll build a small version of the Xception network. We haven't\nparticularly tried to optimize the architecture; if you want to do a\nsystematic search for the best model configuration, consider using\n[KerasTuner](https://github.com/keras-team/keras-tuner).\n\nNote that:\n\n-   We start the model with the `data_augmentation` preprocessor,\n    followed by a `Rescaling` layer.\n-   We include a `Dropout` layer before the final classification layer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_model <- function(input_shape, num_classes) {\n\n  inputs <- layer_input(shape = input_shape)\n\n  x <- inputs %>%\n    # data augmentation() ? %>%\n    layer_rescaling(1.0 / 255)\n\n  x <- x %>%\n    layer_conv_2d(128, 3, strides = 2, padding = \"same\") %>%\n    layer_batch_normalization() %>%\n    layer_activation(\"relu\")\n\n  previous_block_activation <- x  # Set aside residual\n  for (size in c(256, 512, 728)) {\n    x <- x %>%\n      layer_activation(\"relu\") %>%\n      layer_separable_conv_2d(size, 3, padding = \"same\") %>%\n      layer_batch_normalization() %>%\n\n      layer_activation(\"relu\") %>%\n      layer_separable_conv_2d(size, 3, padding = \"same\") %>%\n      layer_batch_normalization() %>%\n\n      layer_max_pooling_2d(3, strides = 2, padding = \"same\")\n\n    # Project residual\n    residual <- previous_block_activation %>%\n      layer_conv_2d(filters = size, kernel_size = 1, strides = 2,\n                    padding = \"same\")\n\n    x <- tf$keras$layers$add(list(x, residual))  # Add back residual\n    previous_block_activation <- x  # Set aside next residual\n  }\n\n  x <- x %>%\n    layer_separable_conv_2d(1024, 3, padding = \"same\") %>%\n    layer_batch_normalization() %>%\n    layer_activation(\"relu\") %>%\n    layer_global_average_pooling_2d()\n\n  if (num_classes == 2) {\n    activation <- \"sigmoid\"\n    units <- 1\n  } else {\n    activation <- \"softmax\"\n    units <- num_classes\n  }\n\n  outputs <- x %>%\n    layer_dropout(0.5) %>%\n    layer_dense(units, activation = activation)\n\n  return(keras_model(inputs, outputs))\n}\n\nmodel <- make_model(input_shape = c(image_size, 3), num_classes = 2)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(model)\n```\n\n::: {.cell-output-display}\n![](image_classification_from_scratch_files/figure-html/unnamed-chunk-13-1.png){width=576}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nepochs <- 25\n\ncallbacks <- list(callback_model_checkpoint(\"save_at_{epoch}.keras\"))\nmodel %>% compile(\n  optimizer = optimizer_adam(1e-3),\n  loss = \"binary_crossentropy\",\n  metrics = list(\"accuracy\"),\n)\nhistory <- model %>% fit(\n    train_ds,\n    epochs = epochs,\n    callbacks = callbacks,\n    validation_data = val_ds,\n)\nplot(history)\n```\n\n::: {.cell-output-display}\n![](image_classification_from_scratch_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nWe get to \\>90% validation accuracy after training for 25 epochs on the\nfull dataset (in practice, you can train for 50+ epochs before\nvalidation performance starts degrading).\n\n## Run inference on new data\n\nYou can reload one of the models saved by the checkpoint callback like\nthis:\n\n``` r\nmodel <- load_model_tf(\"save_at_25.keras\")\n```\n\nNote that data augmentation and dropout are inactive at inference time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load an image as a tensor\nimg_tensor <-\n  \"PetImages/Cat/6779.jpg\" %>%\n  tf$io$read_file() %>%\n  tf$io$decode_image() %>%\n  tf$image$resize(as.integer(image_size)) %>%\n  tf$expand_dims(0L)  # Create batch axis\n\nscore <- model %>% predict(img_tensor)\n\ndisplay_image_tensor(img_tensor)\n```\n\n::: {.cell-output-display}\n![](image_classification_from_scratch_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsprintf(\"This image is %.2f%% cat and %.2f%% dog.\", 100 * (1 - score), 100 * score)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"This image is 69.22% cat and 30.78% dog.\"\n```\n:::\n:::\n",
    "supporting": [
      "image_classification_from_scratch_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}